/*jslint node: true, stupid: true */
'use strict';
// Node modules
var args    = require('yargs').argv,
    chalk   = require('chalk'),
    merge   = require('deeply'),
    del     = require('del'),
    fs      = require('fs'),
    gitRev  = require('git-rev-sync'),
    $       = require('cheerio');

// Gulp and plugins
var gulp        = require('gulp'),
    gutil       = require('gulp-util'),
    rjs         = require('gulp-requirejs-bundler'),
    uglify      = require('gulp-uglify'),
    concat      = require('gulp-concat'),
    minifyCSS   = require('gulp-clean-css'),
    htmlreplace = require('gulp-html-replace'),
    jshint      = require('gulp-jshint'),
    vinylize    = require('./lib/vinylize');


// configuration defaults
var defaults = {

    layoutsRoot     : './src/layouts/',
    wiki            : 'meta.wikimedia.org',
    namespace       : 'Config:',
    buildConfigPath : './src/config-from-build.js',
    outputPath      : 'dist/',
    requireConfig   : './src/app/require.config',
    optimizerConfig : {
        out             : 'scripts.js',
        baseUrl         : './src',
        name            : 'app/startup',
        insertRequire   : ['app/startup'],
        paths           : {
            requireLib  : '../node_modules/requirejs/require'
        },
    }
};

/* Helper Functions */
function getStylesheets(html) {
    return $.load(html)('head link[rel="stylesheet"]').map(function() {
        // convert paths like '/src/css/style.css' into './src/css/style.css'
        return '.' + $(this).attr('href');
    }).get();
}

function loadLayout (layoutName, config) {
    try {
        var path = defaults.layoutsRoot + layoutName + '/';
        var styles = getStylesheets(fs.readFileSync(path + 'index.html', 'utf8'));
        var layoutObject = require(path);

        layoutObject.rootPath = path;
        layoutObject.destPath = defaults.outputPath + layoutName + '-' + config + '/';
        layoutObject.cssSources = styles;
        // lint everything because it's easier, may prove annoying with many layouts
        layoutObject.lintSources = ['./src/**/*.js'];
        return layoutObject;
    } catch(e) {
        gutil.log(
            '[ERROR] Layout ' + chalk.white(layoutName) +
            ' invalid or not found in ' + chalk.white(defaults.layoutsRoot)
        );
        gutil.log('[ERROR] ' + e);
        gutil.log(
            '[ERROR] Layouts are: '
            + chalk.white(fs.readdirSync(defaults.layoutsRoot).join(', '))
            + ' .  Make sure your layout respects conventions.'
        );
        throw e;
    }
}

function wrapWithDefine (returnValue) {
    return '// *** Autogenerated, change at your own risk\n' +
           '\'use strict\';\n' +
           'define(function(){ return ' + returnValue + '; });';
}

/* write a configuration object that the config api can prioritize
 */
function writeBuildConfig (config) {
    var wrappedConfig = wrapWithDefine(
        config ?
            JSON.stringify({
                endpoint: defaults.wiki,
                dashboardArticle: defaults.namespace + config,
            }) :
            null
    );
    fs.writeFileSync(defaults.buildConfigPath, wrappedConfig);
}

/* uses the optional --piwik argument to generate piwik instrumentation
 */
function getPiwikScript() {
    if (!args.piwik) {
        return '';
    }
    var parts = args.piwik.split(','),
        host = parts[0],
        id = parts[1];

    if (!host || !id) {
        throw '--piwik must be specified as host,id';
    }

    var template =
    '<!-- Piwik -->' +
    '<script type="text/javascript">' +
      'var _paq = _paq || [];' +
      '_paq.push(["trackPageView"]);' +
      '_paq.push(["enableLinkTracking"]);' +
      '(function() {' +
        'var u="//###host###/";' +
        '_paq.push(["setTrackerUrl", u+"piwik.php"]);' +
        '_paq.push(["setSiteId", ###id###]);' +
        'var d=document, g=d.createElement("script"), s=d.getElementsByTagName("script")[0];' +
        'g.type="text/javascript"; g.async=true; g.defer=true; g.src=u+"piwik.js"; s.parentNode.insertBefore(g,s);' +
      '})();' +
    '</script>' +
    '<noscript><p><img src="//###host###/piwik.php?idsite=###id###" style="border:0;" alt="" /></p></noscript>' +
    '<!-- End Piwik Code -->';

    return template.replace(/###host###/g, host).replace(/###id###/g, id);
}
/* End Helper Functions */

/* Parse Arguments and set Defaults */
var invalid = [];
var justClean = args._.length === 1 && args._.includes('clean');
if (!args.layout) {
    invalid.push('you need the --layout parameter');
}
if (!justClean && !args.config) {
    invalid.push('you need the --config parameter');
}
if (invalid.length) {
    var msg = '[ERROR] ' + invalid.join(', ')
    gutil.log(msg);
    throw(msg);
}

writeBuildConfig(args.config);
var layout = loadLayout(args.layout, args.config);
layout.version = gitRev.short();

gutil.log(
    'Building ' + chalk.white(args.layout) +
    ' configured with ' + chalk.white(args.config) + ' ...'
);

layout.requireJsOptimizerConfig = merge(
    require(defaults.requireConfig),
    defaults.optimizerConfig,
    layout.optimizerConfig
);
/* End Parse Arguments */

/* Gulp Tasks (all tasks are layout-specific, based on the arguments parsed above) */

/**
 * Removes all files from ./dist/ (w/o using streams)
 * you can negate patterns
 */
function clean (callback) {
    return del([layout.destPath], callback);
}

function lint () {
    return gulp.src(layout.lintSources)
        .pipe(jshint())
        .pipe(jshint.reporter('default'));
}

/**
 * Copies any custom or local fonts so the css can find them
 */
function customFonts () {
    var customFonts = 'src/css/fonts/**/*';

    // put fonts in both places, too (TODO: check if subfolder deploys need this)
    return gulp.src([
        customFonts,
    ])
        .pipe(gulp.dest(layout.destPath + 'fonts/'))
        .pipe(gulp.dest(layout.destPath + '../fonts/'));
}

function js () {
    // version the names of all the bundles, so they can bust caches
    Object.keys(layout.requireJsOptimizerConfig.bundles).forEach(function (bundle) {
        layout.requireJsOptimizerConfig.bundles[bundle + '-' + layout.version]
             = layout.requireJsOptimizerConfig.bundles[bundle];
        delete layout.requireJsOptimizerConfig.bundles[bundle];
    });

    // Discovers all AMD dependencies, concatenates together all required .js files, minifies them
    return rjs(layout.requireJsOptimizerConfig)
        .pipe(vinylize())
        .pipe(uglify())
        .pipe(gulp.dest(layout.destPath));
}

function css () {
    return gulp.src(layout.cssSources)
        .pipe(minifyCSS())
        .pipe(concat('styles.css'))
        .pipe(gulp.dest(layout.destPath));
}

/**
 * Copies semantic themes where the css expects them to be
 */
function themes () {
    var semanticThemes = 'src/themes/default/**/*';

    // put themes in both places (TODO: can semantic build overrides prevent this?)
    return gulp.src([
        semanticThemes,
    ])
        .pipe(gulp.dest(layout.destPath + 'themes/default/'))
        .pipe(gulp.dest(layout.destPath + '../themes/default/'));
}

function html () {
    // restore the build config to return nothing so it doesn't break
    // automated or local testing
    writeBuildConfig(null);
    var piwikScript = getPiwikScript();

    return gulp.src(layout.rootPath + 'index.html')
        .pipe(htmlreplace({

        // convert the config wiki article name to a title by splitting any CamelCase
        'title': '<title>' + args.config.replace(/([^ ])([A-Z0-9])/g, '$1 $2') + '</title>',
        // version the styles and scripts to flush old logic from client caches
        'css': 'styles.css?v=' + layout.version,
        'js': 'scripts.js?v=' + layout.version,
        'piwik': piwikScript,

        }))
        .pipe(gulp.dest(layout.destPath));
}

gulp.task('build', gulp.series(clean, lint, customFonts, themes, css, js, html));
gulp.task('default', gulp.series('build'));
/* End Gulp Tasks */
